# nix.toml - Nix flake management tasks for BrainCraft.io
#
# Provides:
# - Nix installation and configuration
# - Flake operations (update, build, check)
# - Shell management
# - Garbage collection
# - Binary cache operations
#
# Task naming convention: nix:action:detail

# =============================================================================
# NIX INSTALLATION & CONFIGURATION
# =============================================================================

["nix:install"]
description = "üì¶ Install Nix using Lix installer (auto-detects platform) ‚Ä¢ nin"
alias = ["nin"]
run = '''
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="${MISE_PROJECT_ROOT}/.config/mise/lib"
. "${SCRIPT_DIR}/common.sh"
. "${SCRIPT_DIR}/nix.sh"

install_nix
'''

["nix:configure"]
description = "üîß Configure Nix for flake development ‚Ä¢ nc"
alias = ["nc"]
run = '''
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="${MISE_PROJECT_ROOT}/.config/mise/lib"
. "${SCRIPT_DIR}/common.sh"
. "${SCRIPT_DIR}/nix.sh"

configure_nix
'''

["nix:uninstall"]
description = "üóëÔ∏è Uninstall Nix from the system ‚Ä¢ nun"
alias = ["nun"]
run = '''
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="${MISE_PROJECT_ROOT}/.config/mise/lib"
. "${SCRIPT_DIR}/common.sh"
. "${SCRIPT_DIR}/nix.sh"

uninstall_nix
'''

# =============================================================================
# FLAKE OPERATIONS
# =============================================================================

["nix:update"]
description = "üîÑ Update flake.lock to latest input versions ‚Ä¢ nu"
alias = ["nu"]
run = '''
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="${MISE_PROJECT_ROOT}/.config/mise/lib"
. "${SCRIPT_DIR}/common.sh"
. "${SCRIPT_DIR}/nix.sh"

update_flake
'''

["nix:update:input"]
description = "üéØ Update a specific flake input ‚Ä¢ nui"
alias = ["nui"]
run = '''
#!/usr/bin/env bash
set -euo pipefail

INPUT="${1:-}"
if [ -z "${INPUT}" ]; then
    printf 'Usage: mise run nix:update:input <input-name>\n' >&2
    printf 'Example: mise run nix:update:input nixpkgs\n' >&2
    exit 1
fi

cd "${MISE_PROJECT_ROOT}"
printf 'Updating flake input: %s\n' "${INPUT}"
nix flake lock --update-input "${INPUT}"
printf 'Done.\n'
'''

["nix:build"]
description = "üî® Build flake outputs ‚Ä¢ nb"
alias = ["nb"]
run = '''
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="${MISE_PROJECT_ROOT}/.config/mise/lib"
. "${SCRIPT_DIR}/common.sh"
. "${SCRIPT_DIR}/nix.sh"

build_flake "${1:-}"
'''

["nix:check"]
description = "‚úì Validate flake configuration ‚Ä¢ nck"
alias = ["nck"]
run = '''
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="${MISE_PROJECT_ROOT}/.config/mise/lib"
. "${SCRIPT_DIR}/common.sh"
. "${SCRIPT_DIR}/nix.sh"

validate_flake
'''

["nix:show"]
description = "üìú Show flake outputs and metadata ‚Ä¢ ns"
alias = ["ns"]
run = '''
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="${MISE_PROJECT_ROOT}/.config/mise/lib"
. "${SCRIPT_DIR}/common.sh"

cd "${MISE_PROJECT_ROOT}"

print_header "Flake Outputs"
nix flake show

printf '\n'
print_header "Flake Metadata"
nix flake metadata
'''

# =============================================================================
# GARBAGE COLLECTION
# =============================================================================

["nix:gc"]
description = "üóëÔ∏è Garbage collect Nix store ‚Ä¢ ngc"
alias = ["ngc"]
run = '''
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="${MISE_PROJECT_ROOT}/.config/mise/lib"
. "${SCRIPT_DIR}/common.sh"
. "${SCRIPT_DIR}/nix.sh"

run_gc "standard"
'''

["nix:gc:aggressive"]
description = "‚ò¢Ô∏è Aggressive garbage collection (removes all old generations) ‚Ä¢ nga"
alias = ["nga"]
run = '''
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="${MISE_PROJECT_ROOT}/.config/mise/lib"
. "${SCRIPT_DIR}/common.sh"
. "${SCRIPT_DIR}/nix.sh"

run_gc "aggressive"
'''

["nix:optimise"]
description = "‚öôÔ∏è Optimise Nix store (deduplicate files) ‚Ä¢ no"
alias = ["no"]
run = '''
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="${MISE_PROJECT_ROOT}/.config/mise/lib"
. "${SCRIPT_DIR}/common.sh"

print_header "Optimising Nix Store"
print_status info "Deduplicating store paths..."
nix-store --optimise
print_status success "Store optimisation complete"
'''

# =============================================================================
# NIX INFORMATION
# =============================================================================

["nix:info"]
description = "‚ÑπÔ∏è Show Nix installation information ‚Ä¢ nif"
alias = ["nif"]
run = '''
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="${MISE_PROJECT_ROOT}/.config/mise/lib"
. "${SCRIPT_DIR}/common.sh"
. "${SCRIPT_DIR}/nix.sh"

print_nix_info
'''

["nix:doctor"]
description = "üè• Run Nix health diagnostics ‚Ä¢ nd"
alias = ["nd"]
run = '''
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="${MISE_PROJECT_ROOT}/.config/mise/lib"
. "${SCRIPT_DIR}/common.sh"
. "${SCRIPT_DIR}/health-checks.sh"

print_header "Nix Health Diagnostics"

# Critical Nix checks
print_subheader "Nix Installation"
run_health_check "Nix installed" "check_nix_installed" "critical"
run_health_check "Nix daemon running" "check_nix_daemon" "critical"
run_health_check "Flakes enabled" "check_nix_flakes" "critical"

# Flake checks
print_subheader "Flake Configuration"
run_health_check "flake.nix exists" "check_flake_exists" "important"
run_health_check "flake.lock exists" "check_flake_lock" "important"

# Optional validation
print_subheader "Validation"
run_health_check "Flake evaluates" "check_flake_eval" "optional"

print_health_summary
'''

# =============================================================================
# BINARY CACHE
# =============================================================================

["nix:cache:enable"]
description = "üìÑ Enable Cachix binary cache ‚Ä¢ nce"
alias = ["nce"]
run = '''
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="${MISE_PROJECT_ROOT}/.config/mise/lib"
. "${SCRIPT_DIR}/common.sh"
. "${SCRIPT_DIR}/nix.sh"

enable_cachix "${CACHIX_NAME:-braincraftio}"
'''

["nix:cache:push"]
description = "üöÄ Push build outputs to Cachix (requires CACHIX_AUTH_TOKEN) ‚Ä¢ ncp"
alias = ["ncp"]
run = '''
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="${MISE_PROJECT_ROOT}/.config/mise/lib"
. "${SCRIPT_DIR}/common.sh"
. "${SCRIPT_DIR}/nix.sh"

push_to_cache "${CACHIX_NAME:-braincraftio}"
'''

# =============================================================================
# REGISTRY MANAGEMENT
# =============================================================================

["nix:registry:add"]
description = "‚ûï Add bcio to local flake registry ‚Ä¢ nra"
alias = ["nra"]
run = '''
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="${MISE_PROJECT_ROOT}/.config/mise/lib"
. "${SCRIPT_DIR}/common.sh"

print_header "Adding Flake Registry Entry"

print_status info "Adding bcio to registry..."
nix registry add bcio github:braincraftio/flake

print_status success "Registry entry added"
printf '\n%bUsage:%b\n' "${BOLD}" "${NC}"
printf '  nix develop bcio          # Base shell\n'
printf '  nix develop bcio#python   # Python shell\n'
printf '  nix develop bcio#full     # Full environment\n'
'''

["nix:registry:list"]
description = "üìã List configured flake registries ‚Ä¢ nrl"
alias = ["nrl"]
run = '''
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="${MISE_PROJECT_ROOT}/.config/mise/lib"
. "${SCRIPT_DIR}/common.sh"

print_header "Flake Registries"
nix registry list
'''

["nix:registry:remove"]
description = "‚ûñ Remove bcio from local flake registry ‚Ä¢ nrr"
alias = ["nrr"]
run = '''
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="${MISE_PROJECT_ROOT}/.config/mise/lib"
. "${SCRIPT_DIR}/common.sh"

print_status info "Removing bcio from registry..."
nix registry remove bcio 2>/dev/null || true
print_status success "Registry entry removed"
'''

# =============================================================================
# QCOW2 VM IMAGE
# =============================================================================

["nix:qcow2"]
description = "üíΩ Build QCOW2 VM image and prepare for local testing ‚Ä¢ nq"
alias = ["nq"]
run = '''
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="${MISE_PROJECT_ROOT}/.config/mise/lib"
. "${SCRIPT_DIR}/common.sh"

print_header "Building QCOW2 VM Image"

# Remove previous build and clean nix store to ensure fresh image
if [ -L "${MISE_PROJECT_ROOT}/result" ] || [ -e "${MISE_PROJECT_ROOT}/result" ]; then
    print_status info "Cleaning previous QCOW2 build..."
    OLD_PATH=$(readlink -f "${MISE_PROJECT_ROOT}/result" 2>/dev/null || true)
    rm -rf "${MISE_PROJECT_ROOT}/result"
    # Delete old store path if it exists
    if [ -n "$OLD_PATH" ] && [ -d "$OLD_PATH" ]; then
        nix store delete "$OLD_PATH" 2>/dev/null || true
    fi
fi

# Build the qcow2 image
print_status info "Building QCOW2 image (this may take a few minutes)..."
cd "${MISE_PROJECT_ROOT}"
nix build .#qcow2

# Take ownership of result directory (nix store is read-only)
print_status info "Taking ownership of result directory..."
sudo chown -R "${USER}:${USER}" result/
sudo chmod -R u+w result/

# Create cloud-init user-data for local testing
print_status info "Creating cloud-init configuration..."
CLOUD_INIT_DIR="/tmp/konductor-cloud-init"
mkdir -p "${CLOUD_INIT_DIR}"

# Detect user SSH public key
SSH_KEY=""
if [ -f "${HOME}/.ssh/id_ed25519.pub" ]; then
    SSH_KEY=$(cat "${HOME}/.ssh/id_ed25519.pub")
elif [ -f "${HOME}/.ssh/id_rsa.pub" ]; then
    SSH_KEY=$(cat "${HOME}/.ssh/id_rsa.pub")
fi

# Create meta-data
cat > "${CLOUD_INIT_DIR}/meta-data" << 'METADATA'
instance-id: konductor-local
local-hostname: konductor
METADATA

# Create user-data with full konductor setup
# Build user list with optional SSH key
if [ -n "${SSH_KEY}" ]; then
    print_status success "SSH key detected and added to cloud-init"
    cat > "${CLOUD_INIT_DIR}/user-data" << USERDATA
#cloud-config
users:
  - name: kc2
    gecos: Konductor User
    groups: users, docker, libvirtd, kvm
    shell: /bin/bash
    plain_text_passwd: kc2
    lock_passwd: false
    ssh_authorized_keys:
      - ${SSH_KEY}
  - name: kc2admin
    gecos: Konductor Admin
    groups: users, wheel, docker, libvirtd, kvm
    shell: /bin/bash
    sudo: ALL=(ALL) NOPASSWD:ALL
    plain_text_passwd: kc2admin
    lock_passwd: false
    ssh_authorized_keys:
      - ${SSH_KEY}

write_files:
  - path: /etc/profile.d/konductor.sh
    content: |
      # Auto-hint for konductor devshell
      if [ -z "\$KONDUCTOR_SHELL" ] && [ -t 0 ]; then
        echo ""
        echo "Konductor VM ready! Enter devshell with:"
        echo "  nix develop konductor#konductor"
        echo ""
      fi
    permissions: '0644'

runcmd:
  # Pre-build devshell closure (full path required - runcmd has minimal PATH)
  - /run/current-system/sw/bin/nix build "konductor#devShells.$(uname -m)-linux.konductor" --no-link --refresh || true
  # Start services after devshell is ready
  - systemctl start docker
  - systemctl start libvirtd
  # Mount 9p workspace if virtfs device exists (runs last to ensure device is ready)
  - mkdir -p /workspace
  - mount -t 9p -o trans=virtio host /workspace || true
USERDATA
else
    print_status warn "No SSH key found in ~/.ssh/ - password auth only"
    cat > "${CLOUD_INIT_DIR}/user-data" << 'USERDATA'
#cloud-config
users:
  - name: kc2
    gecos: Konductor User
    groups: users, docker, libvirtd, kvm
    shell: /bin/bash
    plain_text_passwd: kc2
    lock_passwd: false
  - name: kc2admin
    gecos: Konductor Admin
    groups: users, wheel, docker, libvirtd, kvm
    shell: /bin/bash
    sudo: ALL=(ALL) NOPASSWD:ALL
    plain_text_passwd: kc2admin
    lock_passwd: false

write_files:
  - path: /etc/profile.d/konductor.sh
    content: |
      # Auto-hint for konductor devshell
      if [ -z "$KONDUCTOR_SHELL" ] && [ -t 0 ]; then
        echo ""
        echo "Konductor VM ready! Enter devshell with:"
        echo "  nix develop konductor#konductor"
        echo ""
      fi
    permissions: '0644'

runcmd:
  # Pre-build devshell closure (full path required - runcmd has minimal PATH)
  - /run/current-system/sw/bin/nix build "konductor#devShells.$(uname -m)-linux.konductor" --no-link --refresh || true
  # Start services after devshell is ready
  - systemctl start docker
  - systemctl start libvirtd
  # Mount 9p workspace if virtfs device exists (runs last to ensure device is ready)
  - mkdir -p /workspace
  - mount -t 9p -o trans=virtio host /workspace || true
USERDATA
fi

# Create cloud-init ISO (NoCloud datasource)
print_status info "Creating cloud-init ISO..."
if command -v genisoimage >/dev/null 2>&1; then
    genisoimage -output "${CLOUD_INIT_DIR}/seed.iso" \
        -volid cidata -joliet -rock \
        "${CLOUD_INIT_DIR}/user-data" "${CLOUD_INIT_DIR}/meta-data" 2>/dev/null
elif command -v mkisofs >/dev/null 2>&1; then
    mkisofs -output "${CLOUD_INIT_DIR}/seed.iso" \
        -volid cidata -joliet -rock \
        "${CLOUD_INIT_DIR}/user-data" "${CLOUD_INIT_DIR}/meta-data" 2>/dev/null
else
    print_status error "Neither genisoimage nor mkisofs found. Install cdrtools or cdrkit."
    exit 1
fi

print_status success "QCOW2 image ready!"

printf '\n'
print_header "Launch Commands"

printf '\n%bSerial Console (interactive):%b\n' "${BOLD}" "${NC}"
printf '  qemu-system-x86_64 -m 4096 -smp 2 -enable-kvm \\\n'
printf '    -drive file=%s/result/nixos.qcow2,if=virtio,format=qcow2 \\\n' "${MISE_PROJECT_ROOT}"
printf '    -drive file=%s/seed.iso,media=cdrom \\\n' "${CLOUD_INIT_DIR}"
printf '    -nic user,hostfwd=tcp::2222-:22 \\\n'
printf '    -nographic -serial mon:stdio\n'

printf '\n%bHeadless (SSH access):%b\n' "${BOLD}" "${NC}"
printf '  qemu-system-x86_64 -m 4096 -smp 2 -enable-kvm \\\n'
printf '    -drive file=%s/result/nixos.qcow2,if=virtio,format=qcow2 \\\n' "${MISE_PROJECT_ROOT}"
printf '    -drive file=%s/seed.iso,media=cdrom \\\n' "${CLOUD_INIT_DIR}"
printf '    -nic user,hostfwd=tcp::2222-:22 \\\n'
printf '    -daemonize\n'
printf '\n  # Then SSH:\n'
printf '  ssh -p 2222 kc2@localhost\n'
printf '  ssh -p 2222 kc2admin@localhost  # (sudo access)\n'

printf '\n%bWith Shared Repo (development):%b\n' "${BOLD}" "${NC}"
printf '  qemu-system-x86_64 -machine q35,accel=kvm -m 8192 -cpu host -smp 4 \\\n'
printf '    -drive file=%s/result/nixos.qcow2,if=virtio,format=qcow2 \\\n' "${MISE_PROJECT_ROOT}"
printf '    -drive file=%s/seed.iso,media=cdrom \\\n' "${CLOUD_INIT_DIR}"
printf '    -netdev user,id=net0,hostfwd=tcp::2222-:22 \\\n'
printf '    -device virtio-net-pci,netdev=net0 \\\n'
printf '    -device virtio-balloon-pci \\\n'
printf '    -device virtio-rng-pci \\\n'
printf '    -virtfs local,path=%s,mount_tag=host,security_model=mapped-xattr \\\n' "${MISE_PROJECT_ROOT}"
printf '    -nographic -serial mon:stdio\n'
printf '\n  # Inside VM: mount shared repo\n'
printf '  sudo mkdir -p /workspace\n'
printf '  sudo mount -t 9p -o trans=virtio host /workspace\n'
printf '  cd /workspace && nix develop konductor#konductor\n'

printf '\n%bCredentials:%b\n' "${BOLD}" "${NC}"
printf '  kc2      / kc2       (unprivileged user)\n'
printf '  kc2admin / kc2admin  (sudo access)\n'

if [ -n "${SSH_KEY}" ]; then
    printf '\n%bSSH Key:%b Your public key has been injected\n' "${BOLD}" "${NC}"
fi

printf '\n%bCloud-Init Auto-Setup:%b\n' "${BOLD}" "${NC}"
printf '  - docker and libvirtd services started\n'
printf '  - konductor#konductor devshell pre-built\n'
printf '  - Enter with: nix develop konductor#konductor\n'

printf '\n%bKVM Access:%b If permission denied, run:\n' "${BOLD}" "${NC}"
printf '  sudo usermod -aG kvm $USER && newgrp kvm\n'
'''
